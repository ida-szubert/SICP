#lang planet neil/sicp
;Exercise 3.51

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc s)
  (if (stream-null? s)
      the-empty-stream
      (cons-stream (proc (stream-car s)) (stream-map proc (stream-cdr s)))))

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream low (stream-enumerate-interval (+ low 1) high))))

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))
(define (stream-null? s) (null? s))
(define (the-empty-stream) '())

(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))

(define (show x)
  (display-line x)
  x)

;What does the interpreter print in response to evaluating each expression in the following sequence?
(define x
  (stream-map show (stream-enumerate-interval 0 10)))

(stream-ref x 5)
;looks for the 6th element of the stream
;the stream we are talking about is produced by show maped over the stream generated by enumerate-interval 0 10
;to get the result, we start by evaluating x
;we get (cons 0 (delay (stream-enumerate-interval 1 10))), and in the course of evaluation 0 is printed out
;but, 5=/=0, so we need to evaluate (cdr x)
;getting (cons 1 (delay (stream-enumerate-interval 2 10))), and printing out 1 in the process
;5=/=1, so we evaluate cdr again
;we do it as long as we reach the 6th element, which stream-ref returns as its answer
;so the output should be sth along the lines of
;0
;1
;2
;3
;4
;5
;5

(stream-ref x 7)
;looks for the 8th element
;6
;7
;7
;so, we're not constructing the x stream from scratch
;in the previous call to stream-ref we've created the stream (0 1 2 3 4 5 (stream-map show (delay (stream-enumerate 6 10))))
;so the current call to stream-ref goes through the first 6 elements without printing them out, because show was already applied to this portion
;of the stream generated by (stream-enumerate-interval 0 10)

;Exercise 3.52
(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream) (stream-filter pred (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(define sum 0)
(define (accum x) (set! sum (+ x sum)) sum)
(define seq
  (stream-map accum
              (stream-enumerate-interval 1 20)))
(define y (stream-filter even? seq))
(define z (stream-filter (lambda (x) (= (remainder x 5) 0)) seq))

;What is the value of sum after each of the following expressions is evaluated?
(stream-ref y 7)
;start by evaluating y
;evaluate seq
;evaluate (stream-enumerate-interval 1 20)
;get (cons 1 (s-e-i 2 20))
;apply accum to car of this stream
;set sum to 1
;seq is now (cons 1 (stream-map accum (s-e-i 2 20)))
;y filters it with even?
;1 is not even, and thus does not get consed onto the stream generated by y's procedure
;so we reach for the next item in the seq
;accum 2 sets sum to 3 and returns 3
;therefore 3 is the second element of seq
;it's not even either, so it doesn't become part of y
;next element of seq is 6 (accum 3)
;it becomes the first element of y
;the sequence of operations repreats for as long as we cons the 8th element onto y
;the result is 136

(display-stream z)
;the fully fleshed out seq is needed for this one
;(1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210)
;and while seq is being created, it's filtered so that only elements divisible by 5 are included in z
;(10 15 45 55 115 130 200 220)
;so the output should be
;10
;15
;45
;55
;105
;120
;190
;210

;Without memoization we would need to call accum many more times
;to calculate each element of seq we would accum from the beggining of the s-e-i 1 20
;the results weould be different, and not what we expect
;that's because of assignment being involved
;were accum a function without assignment, there could be no difference between meoized and non-memoized version
